<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beam Calculator</title>
    
	<!--The includes-->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
		integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
		crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
		integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
		crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
		integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
		crossorigin="anonymous"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js"></script>
	<link rel="stylesheet" type="text/css"
		href="https://cdn.jsdelivr.net/gh/kenwheeler/slick@1.8.1/slick/slick-theme.css" />
	<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css" />

	<!-- Bootstrap CSS -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
		integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    
    <!-- Font Awsome -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
	<style>
		table{
			border: 2px solid #cdcdcd;
		}
		td, th{
			padding-left: 10px;
			padding-right: 10px;
			text-align: center;
			border: 1px solid #c7c7c7;
		}
		input{
			text-align: left;
			border: none;
			width: 100%;
		}
		.param-label{
			text-align: end;
		}
	</style>
  </head>

  <body><div class="row">
	<div class="column"  style="width: calc(100% - 600px);">
		<table style="width: 100%;">
			<tr>
				<th> Parameter</th><th>Symbol</th><th>Value</th><th>Unit</th>
			</tr>
			<tr><th colspan="4">Beam 1 definition</th></tr>
			<tr>
				<td class="param-label">Length</td><td>L<sub>1</sub></td><td><input value="50" type="number" min="10" max="80" step="0.5" id="eL1"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Forced displacement point</td><td>L<sub>A1</sub></td><td><input value="20" type="number" min="10" max="80" step="0.5" id="eLA1"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Sheet Thickness</td><td>d<sub>1</sub></td><td><input value="0.5" type="number" min="0.05" max="10" step="0.1" id="ed1"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Beam Width</td><td>b<sub>1</sub></td><td><input value="5" type="number" min="3" max="20" step="0.5" id="eb1"></td><td>mm</td>
			</tr>
			<tr><th colspan="4">Beam 2 definition</th></tr>
			
			<tr>
				<td class="param-label">Length</td><td>L<sub>2</sub></td><td><input value="50" type="number" min="10" max="80" step="0.5" id="eL2"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Forced displacement point</td><td>L<sub>A2</sub></td><td><input value="40" type="number" min="10" max="80" step="0.5" id="eLA2"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Sheet Thickness</td><td>d<sub>2</sub></td><td><input value="5" type="number" min="0.05" max="10" step="0.1" id="ed2"></td><td>mm</td>
			</tr>
			<tr>
				<td class="param-label">Beam Width</td><td>b<sub>2</sub></td><td><input value="10" type="number" min="3" max="20" step="0.5" id="eb2"></td><td>mm</td>
			</tr>
			<tr><th colspan="4">Common Characteristics</th></tr>
			<tr>
				<td class="param-label">Modulus of elasticity</td><td>E</td><td><input value="200" type="number" min="10" max="10000" step="10" id="eE"></td><td>GPa</td>
			</tr>
			<tr>
				<td class="param-label">Motor stepping</td><td>R<sub>m</sub></td><td><input value="6400" type="number" min="50" max="64000" step="200" id="eStepping"></td><td>steps/rev</td>
			</tr>
			<tr>
				<td class="param-label">Screw pitch</td><td>R<sub>m</sub></td><td><input value="0.5" type="number" min="0.1" max="1" step="1000" id="eSP"></td><td>mm/rev</td>
			</tr>
			<tr><th colspan="4">Results (E2E Config)</th></tr>
			<tr>
				<td class="param-label">Fine transfer function</td><td>ToF<sub>f</sub></td><td><span id="eToF_F_E2E"></span></td><td>--</td>
			</tr>
			<tr>
				<td class="param-label">Fine resolution </td><td>R<sub>f</sub></td><td><span id="eR_F_E2E"></span></td><td>nm/step</td>
			</tr>
			<tr><th colspan="4">Results (E2MP Config)</th></tr>
			<tr>
				<td class="param-label">Fine transfer function</td><td>ToF<sub>f</sub></td><td><span id="eToF_F_E2MP"></span></td><td>--</td>
			</tr>
			<tr>
				<td class="param-label">Fine resolution </td><td>R<sub>f</sub></td><td><span id="eR_F_E2MP"></span></td><td>nm/step</td>
			</tr>
		</table>
	</div>
	<div class="column"  style="width: 600px;">
		<canvas id="canvas" style="width: 99%; height: calc(100vh - 30px);"></canvas>
	</div>
  </div>
	
	<script>
		var b_1, d_1 = 0, b_2 = 0, d_2 = 0, I_1 = 0, I_2 = 0, E_1 = 0, E_2 = 0, L_1 = 0, L_2 = 0, La_1 = 0, La_2 = 0, LCM_1 = 0, LCM_2 = 0, SP_1 = 0, SP_2 = 0;
		
		function round(num, divider){
			return Math.round(num * divider) / divider;
		}

		function analysis1(){
			var lc_1 = SP_1 / LCM_1;
			var lc_2 = SP_2 / LCM_2;


			var ToF_F_E2E = document.getElementById("eToF_F_E2E");
			var R_F_E2E = document.getElementById("eR_F_E2E");

			var ToF_F_E2MP = document.getElementById("eToF_F_E2MP");
			var R_F_E2MP = document.getElementById("eR_F_E2MP");

			b_1 = document.getElementById("eb1").value / 1000;
			d_1 = document.getElementById("ed1").value / 1000;
			b_2 = document.getElementById("eb2").value / 1000;
			d_2 = document.getElementById("ed2").value / 1000;			
			I_1 = b_1 * Math.pow(d_1, 3) / 12;
			I_2 = b_2 * Math.pow(d_2, 3) / 12;
			E_1 = document.getElementById("eE").value / 1000;
			E_2 = document.getElementById("eE").value / 1000;
			L_1 = document.getElementById("eL1").value / 1000;
			L_2 = document.getElementById("eL2").value / 1000;
			La_1 = document.getElementById("eLA1").value / 1000;
			La_2 = document.getElementById("eLA2").value / 1000;
			LCM_1 = document.getElementById("eStepping").value;
			LCM_2 = document.getElementById("eStepping").value;
			SP_1 = document.getElementById("eSP").value;
			SP_2 = document.getElementById("eSP").value;

			// console.log('E_1', E_1);
			// console.log('I_1', I_1);
			// console.log('L_1', L_1);
			// console.log('La_1', La_1);
			// console.log('LC_1', LC_1);

			// End at mid point
			function nanoMovementE2MP(ta_1, te_2)
			{
				// Application is made at point e
				var ta_2 = (- 12*E_2*b_2*te_2*L_1**3*L_2*La_1*La_2**2*d_2**3 + 4*E_2*b_2*te_2*L_1**3*La_1*La_2**3*d_2**3 + 27*E_2*b_2*te_2*L_1**2*L_2*La_1**2*La_2**2*d_2**3 - 9*E_2*b_2*te_2*L_1**2*La_1**2*La_2**3*d_2**3 - 12*E_1*b_1*ta_1*L_1*L_2**3*La_2**3*d_1**3 + 27*E_1*b_1*ta_1*L_1*L_2**2*La_2**4*d_1**3 - 18*E_2*b_2*te_2*L_1*L_2*La_1**3*La_2**2*d_2**3 - 18*E_1*b_1*ta_1*L_1*L_2*La_2**5*d_1**3 + 6*E_2*b_2*te_2*L_1*La_1**3*La_2**3*d_2**3 + 3*E_1*b_1*ta_1*L_1*La_2**6*d_1**3 + 4*E_1*b_1*ta_1*L_2**3*La_1*La_2**3*d_1**3 - 9*E_1*b_1*ta_1*L_2**2*La_1*La_2**4*d_1**3 + 3*E_2*b_2*te_2*L_2*La_1**4*La_2**2*d_2**3 + 6*E_1*b_1*ta_1*L_2*La_1*La_2**5*d_1**3 - E_2*b_2*te_2*La_1**4*La_2**3*d_2**3 - E_1*b_1*ta_1*La_1*La_2**6*d_1**3)/(- 8*E_1*b_2*L_1**3*L_2**3*La_1*d_2**3 + 18*E_1*b_2*L_1**2*L_2**3*La_1**2*d_2**3 - 12*E_1*b_2*L_1*L_2**3*La_1**3*d_2**3 + 2*E_1*b_2*L_2**3*La_1**4*d_2**3 - 8*E_1*b_1*L_2**3*La_1*La_2**3*d_1**3 + 18*E_1*b_1*L_2**2*La_1*La_2**4*d_1**3 - 12*E_1*b_1*L_2*La_1*La_2**5*d_1**3 + 2*E_1*b_1*La_1*La_2**6*d_1**3);
				// console.log('ta_1', ta_1);
				// console.log('ta_2', ta_2);
				// console.log("te_2 = ", te_2)
				return ta_2;
			}
			// End to End
			function nanoMovementE2E(ta_1, ta_2)
			{
				var te_2 = (- 12*E_1*b_2*ta_2*L_1**3*L_2*La_1*d_2**3 + 4*E_1*b_2*ta_2*L_1**3*La_1*La_2*d_2**3 + 27*E_1*b_2*ta_2*L_1**2*L_2*La_1**2*d_2**3 - 9*E_1*b_2*ta_2*L_1**2*La_1**2*La_2*d_2**3 - 12*E_1*b_1*ta_1*L_1*L_2**3*La_2*d_1**3 + 27*E_1*b_1*ta_1*L_1*L_2**2*La_2**2*d_1**3 - 18*E_1*b_2*ta_2*L_1*L_2*La_1**3*d_2**3 - 18*E_1*b_1*ta_1*L_1*L_2*La_2**3*d_1**3 + 6*E_1*b_2*ta_2*L_1*La_1**3*La_2*d_2**3 + 3*E_1*b_1*ta_1*L_1*La_2**4*d_1**3 + 4*E_1*b_1*ta_1*L_2**3*La_1*La_2*d_1**3 - 9*E_1*b_1*ta_1*L_2**2*La_1*La_2**2*d_1**3 + 3*E_1*b_2*ta_2*L_2*La_1**4*d_2**3 + 6*E_1*b_1*ta_1*L_2*La_1*La_2**3*d_1**3 - E_1*b_2*ta_2*La_1**4*La_2*d_2**3 - E_1*b_1*ta_1*La_1*La_2**4*d_1**3)/(- 8*E_2*b_2*L_1**3*La_1*La_2*d_2**3 + 18*E_2*b_2*L_1**2*La_1**2*La_2*d_2**3 - 12*E_2*b_2*L_1*La_1**3*La_2*d_2**3 - 8*E_1*b_1*L_2**3*La_1*La_2*d_1**3 + 18*E_1*b_1*L_2**2*La_1*La_2**2*d_1**3 - 12*E_1*b_1*L_2*La_1*La_2**3*d_1**3 + 2*E_2*b_2*La_1**4*La_2*d_2**3 + 2*E_1*b_1*La_1*La_2**4*d_1**3);
				// console.log('ta_1', ta_1);
				// console.log('ta_2', ta_2);
				// console.log("te_2 = ", te_2)
				return te_2;
			}

			// E2E
			var t1 = nanoMovementE2E(lc_1, 0);
			var t2 = nanoMovementE2E(lc_1 + lc_1, 0);
			var tn = t2 - t1;
    		var TF = tn / lc_1
			ToF_F_E2E.innerHTML = round(tn / lc_1, 100000);
			R_F_E2E.innerHTML = round(tn * 1e9, 100);

			// E2MP
			var t1 = nanoMovementE2MP(lc_1, 0);
			var t2 = nanoMovementE2MP(lc_1 + lc_1, 0);
			var tn = t2 - t1;
    		var TF = tn / lc_1
			ToF_F_E2MP.innerHTML = round(tn / lc_1, 100000);
			R_F_E2MP.innerHTML = round(tn * 1e9, 100);
		}
		function getSIVal(element){
			var mult = 1;
			if (element.startsWith("eL"))
				mult = 0.001;
			else if (element.startsWith("eE"))
				mult = 1000000;
			return document.getElementById(element).value * mult;
		}
		// Get all input elements of a specific type
		var canvas = document.getElementById("canvas");
		var ctx = canvas.getContext("2d");
		const inputs = document.querySelectorAll('input[type="number"]');
		
		function fillRect(x,y, w, h, c){	
			ctx.save();	
			console.log(`Fill rect: ${x}, ${y} , ${w}x${h}`);
			ctx.beginPath();
			ctx.fillStyle = c;
			ctx.rect(x, y, w, h);
			ctx.fill();
			ctx.restore();
		}
		function drawLine(x1, y1, x2, y2, t, c){		
			ctx.save();	
			ctx.strokeStyle = c; // Line color
			ctx.lineWidth = t; // Line width

			// Draw a line from point (x1, y1) to point (x2, y2)
			ctx.beginPath();
			ctx.moveTo(x1, y1); // Starting point coordinates
			ctx.lineTo(x2, y2); // Ending point coordinates
			ctx.stroke(); // Draw the line
			ctx.restore();
		}
		function drawRect(x,y, w, h, t, c){
			ctx.save();
			console.log(`Draw rect: ${x}, ${y} , ${w}x${h}`);
			ctx.beginPath();
			ctx.lineWidth = t;
			ctx.strokeStyle = c;
			ctx.rect(x, y, w, h);
			ctx.stroke();
			ctx.restore();
		}
		function drawArrow(x1, y1, x2, y2, lineThickness, arrow1Width, arrow2Width, color){
			//variables to be used when creating the arrow
			var headlen = arrow1Width;
			var angle = Math.atan2(y2-y1,x2-x1);

			ctx.save();
			ctx.strokeStyle = color;
		
			//starting path of the arrow from the start square to the end square
			//and drawing the stroke
			ctx.beginPath();
			ctx.moveTo(x1 + arrow1Width / 2 * Math.cos(angle), y1 + arrow1Width / 2 * Math.sin(angle));
			// Lets offset the point to avoid coming out of the arrow head
			ctx.lineTo(x2 - arrow2Width / 2 * Math.cos(angle), y2 - arrow2Width / 2 * Math.sin(angle));
			ctx.lineWidth = lineThickness;
			ctx.stroke();
		
			ctx.fillStyle = color;

			if (arrow1Width > 0){
				// Start Arrow
				//starting a new path from the head of the arrow to one of the sides of
				//the point
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x1 + headlen*Math.cos(angle-Math.PI/7),
						y1+headlen*Math.sin(angle-Math.PI/7));
			
				//path from the side point of the arrow, to the other side point
				ctx.lineTo(x1+headlen*Math.cos(angle+Math.PI/7),
						y1+headlen*Math.sin(angle+Math.PI/7));
			
				//path from the side point back to the tip of the arrow, and then
				//again to the opposite side point
				ctx.lineTo(x1, y1);
				ctx.lineTo(x1-headlen*Math.cos(angle-Math.PI/7),
						y1+headlen*Math.sin(angle-Math.PI/7));
			
				//draws the paths created above
				//ctx.stroke();
				ctx.fill();
			}
			if (arrow2Width > 0){
				headlen = arrow2Width;
				// End Arrow			
				//starting a new path from the head of the arrow to one of the sides of
				//the point
				ctx.beginPath();
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2-headlen*Math.cos(angle-Math.PI/7),
						y2-headlen*Math.sin(angle-Math.PI/7));
			
				//path from the side point of the arrow, to the other side point
				ctx.lineTo(x2-headlen*Math.cos(angle+Math.PI/7),
						y2-headlen*Math.sin(angle+Math.PI/7));
			
				//path from the side point back to the tip of the arrow, and then
				//again to the opposite side point
				ctx.lineTo(x2, y2);
				ctx.lineTo(x2-headlen*Math.cos(angle-Math.PI/7),
						y2-headlen*Math.sin(angle-Math.PI/7));
			
				//draws the paths created above
				//ctx.stroke();
				ctx.fill(); 
			}
			ctx.restore();
		}
		function drawBase(x, y, hatchWidth, height, pitch){
			height -= hatchWidth / 2;
			y += hatchWidth / 4;
			var wallLineThickness = 0.5;
			drawLine(x - wallLineThickness / 2, y - height / 2, x - wallLineThickness / 2, y + height / 2 + pitch, wallLineThickness, 'black')
			for (var i = -height / 2; i <= height / 2; i += pitch){
				drawLine(x, i + y, x + hatchWidth, i + y - hatchWidth, wallLineThickness / 3, 'black')
			}

		}
		function drawText(text, x, y, width, height, color, font) {
			ctx.fillStyle = color; // Set text color
			ctx.font = font; // Set font style

			// Set text alignment to center horizontally and vertically
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			// Calculate the center coordinates for anchoring the text
			var centerX = x + width / 2;
			var centerY = y + height / 2;

			// Draw the text at the center coordinates
			ctx.fillText(text, centerX, centerY);
		}
		function dimension(x1, y1, x2, y2, offset, text){
			var angle = Math.atan2(y2 - y1, x2 - x1);
			var dimOut = 2;
			if (offset < 0) dimOut *= -1;
			var arrowx1 = x1 + offset * Math.cos(angle + Math.PI / 2);
			var arrowy1 = y1 + offset *Math.sin(angle + Math.PI / 2);
			
			var arrowx2 = x2 + offset * Math.cos(angle + Math.PI / 2);
			var arrowy2 = y2 + offset * Math.sin(angle + Math.PI / 2);
			
			var dimx1 = x1 + (offset + dimOut) * Math.cos(angle + Math.PI / 2);
			var dimy1 = y1 + (offset + dimOut) *Math.sin(angle + Math.PI / 2);			
			var dimx2 = x2 + (offset + dimOut) * Math.cos(angle + Math.PI / 2);
			var dimy2 = y2 + (offset + dimOut) * Math.sin(angle + Math.PI / 2);

			drawLine(x1, y1, dimx1, dimy1, 0.2, "blue");
			drawLine(x2, y2, dimx2, dimy2, 0.2, "blue");
			drawArrow(arrowx1, arrowy1, arrowx2, arrowy2, 0.2, 3, 3, "blue")

			ctx.save();
			ctx.rotate(angle);
			ctx.translate((x1 + x2) / 2, (y1 + y2) / 2 + offset - 2);
			drawText(text, 0, 0, 0, 0, 'purple', "3px arial");
			ctx.restore();
		}
		function drawBeam(x, y, L, d){
			//Base
			drawBase(x, y, -5, d + 5, 2);
			// Main Beam
			fillRect(x, y - d / 2, L, d, 'darkgray');
			drawRect(x, y - d / 2, L, d, 0.1, 'black');
		}

		function refreshGraphics(){
            // Scale the graphics context
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.save(); // S0
			// Scale for 100% max width
            ctx.scale(canvas.clientWidth / 100, canvas.clientWidth / 100);
			
			// Translate and scale for beam base
			ctx.translate(10, 0);
			ctx.scale(0.8, 0.8); // 10 clearance on both side

			
			// Conf 1
			var scale = 1 / Math.max(L_1, L_2) * 100;
			var yPos1 = 25;
			var yPos2 = 60;		
			var forceLength = 20;	
			// Beam 1
			ctx.save(); // S1
			ctx.translate((Math.max(L_1, L_2) - L_1) * scale, 0);
			drawBeam(0, yPos1, L_1 * scale, d_1 * scale);
			// Force 
			drawArrow(La_1 * scale, yPos1 - forceLength - d_1 / 2 * scale, La_1 * scale, yPos1 - d_1 / 2 * scale, 1, 0, 4, '#FF0000A0');		
			dimension(0, yPos1, La_1 * scale, yPos1, -d_1 / 2 * scale + 8, "La_1")	
			dimension(0, yPos1, L_1 * scale, yPos1, d_1 / 2 * scale - 15, "L_1")
			ctx.restore(); // S1

			// Beam 2
			ctx.save(); // S1
			ctx.translate((Math.max(L_1, L_2) - L_2) * scale, 0);
			drawBeam(0, yPos2, L_2 * scale, d_2 * scale);
			// Force 
			drawArrow(La_2 * scale, yPos2 - forceLength - d_2 / 2 * scale, La_2 * scale, yPos2 - d_2 / 2 * scale, 1, 0, 4, '#FF0000A0');
			dimension(0, yPos2, La_2 * scale, yPos2, d_2 / 2 * scale + 10, "La_2")
			dimension(0, yPos2, L_2 * scale, yPos2, d_2 / 2 * scale + 15, "L_2")
			ctx.restore(); // S1

			// Force 
    		ctx.setLineDash([1]); // Set dash pattern (dashLength is the length of each dash)
			drawLine(Math.max(L_1, L_2) * scale, yPos1 + d_1 / 2 * scale, Math.max(L_1, L_2) * scale, yPos2 - d_2 / 2 * scale, 1, 'red');
			ctx.setLineDash([]); // Set dash pattern (dashLength is the length of each dash)
			
			// End Vetor
			drawArrow(Math.max(L_1, L_2)* scale, yPos2 + d_2 / 2 * scale, Math.max(L_1, L_2) * scale, yPos2 + d_2 / 2 * scale + 10, 1, 0, 5, 'orange');

			
			// Conf 2
			if(La_2 > L_1)
				scale = 1 / L_2 * 100;
			else
				scale = scale = 1 / (L_1 + (L_2 - La_2)) * 100;
			yPos1 = 25;
			yPos2 = 60;		
			// Beam 1
			ctx.save(); // S1
			ctx.translate(0, 90); // page 2
			ctx.save(); // S2
			if(La_2 > L_1)
				ctx.translate((La_2 - L_1) * scale, 0);
			drawBeam(0, yPos1, L_1 * scale, d_1 * scale);
			// Force 
			drawArrow(La_1 * scale, yPos1 - forceLength - d_1 / 2 * scale, La_1 * scale, yPos1 - d_1 / 2 * scale, 1, 0, 4, '#FF0000A0');		
			dimension(0, yPos1, L_1 * scale, yPos1, d_1 / 2 * scale - 15, "L_1")
			dimension(0, yPos1, La_1 * scale, yPos1, -d_1 / 2 * scale + 8, "La_1")	
			ctx.restore(); // S1

			// Beam 2
			ctx.save(); // S1
			if(L_1 > La_2)
				ctx.translate((L_1 - La_2) * scale, 0);
			drawBeam(0, yPos2, L_2 * scale, d_2 * scale);
			// Force 
			drawArrow(L_2 * scale, yPos2 - forceLength - d_2 / 2 * scale, L_2 * scale, yPos2 - d_2 / 2 * scale, 1, 0, 4, '#FF0000A0');
			
			// Join 
    		ctx.setLineDash([1]); // Set dash pattern (dashLength is the length of each dash)
			drawLine(La_2 * scale, yPos1 + d_1 / 2 * scale, La_2 * scale, yPos2 - d_2 / 2 * scale, 1, 'red');
			ctx.setLineDash([]); // Set dash pattern (dashLength is the length of each dash)
			
			dimension(0, yPos2, La_2 * scale, yPos2, d_2 / 2 * scale + 10, "L_2")
			dimension(0, yPos2, L_2 * scale, yPos2, d_2 / 2 * scale + 15, "La_2")
			ctx.restore(); // S1

			
			// End Vetor
			if(La_2 > L_1)
				ctx.translate((La_2 - L_1) * scale, 0);
			drawArrow(L_1 * scale, yPos2 + d_2 / 2 * scale, L_1 * scale, yPos2 + d_2 / 2 * scale + 10, 1, 0, 5, 'orange');

			ctx.restore(); // S1
			ctx.restore(); // S0
		}
        // Function to resize the canvas and its graphics buffer
        function resizeCanvas() {
            // Get the computed width and height of the canvas container
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            // Set the canvas element's width and height attributes
            canvas.width = width;
            canvas.height = height;

            // Redraw your graphics after resizing if needed
            refreshGraphics();
        }
        // Call the resizeCanvas function initially and when the window is resized
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

		// Add an event listener to each input element
		inputs.forEach(input => {
			input.addEventListener('input', event => {
				// Your event handling code here
				console.log(input.id + ' value changed:', event.target.value);
				refreshGraphics();
				analysis1();
			});
		});
		analysis1();
		refreshGraphics();
		analysis1();
		refreshGraphics();

	</script>
  </body>
</html>
